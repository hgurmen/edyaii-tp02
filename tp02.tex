\nonstopmode

\usepackage{fullpage}

\documentclass[a4paper,10pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage[margin=1in]{geometry}

\author{
    Hernán Gurmendi \\
    \texttt{hgurmen@gmail.com}
    \and Nicolás Mendez Shurman \\
    \texttt{nicol12b@gmail.com}
}

\date{
    4 de junio de 2015
}

\title{
    \Huge Especificación de costos \\
    \Large Estructuras de Datos y Algoritmos II \\
    \large Trabajo práctico 2
}

\begin{document}

\maketitle

\begin{center}
\large \bf Docentes
\end{center}

\begin{center}
Mauro Jaskelioff

Cecila Manzino

Juan M. Rabasedas

Eugenia Simich
\end{center}

\newpage{}


\part*{Implementación con listas}


\section*{\texttt{filterS}}

La implementación de \texttt{filterS} con listas es similar a la función \texttt{filter}
del \texttt{Prelude}, salvo que en el caso de una lista con más de un elemento se
calcula el predicado con el primer elemento, en paralelo al cálculo del paso
recursivo, de forma que para el trabajo se obtiene la suma de los trabajos de los
predicados y para la profundidad se obtiene la suma de la profundidad de los
predicados, tal como se nota a continuación:

% \; is a thick space
% \vert is |
% \left( is big left parenthesis
% \right) is big right parenthesis
% \sum is summatory.
% \max is max (math mode)
% \mathbf is bold formatting

\begin{equation*}
    W \left( filterS\; f \; s \right) \in
    O \left( \sum_{i=0}^{\vert s \vert -1} W \left( f \; s_i \right) \right)
\end{equation*}

\begin{equation*}
    S \left( filterS\; f \; s \right) \in
    O \left( \vert s \vert + \max_{i=0}^{\vert s \vert -1} S \left( f \; s_i \right) \right)
\end{equation*}


\section*{\texttt{showtS}}

\texttt{showtS} precisa partir la lista dada en dos mitades, de modo que necesita
utilizar las funciones \texttt{take} y \texttt{drop} (que en el caso de la
implementación con listas son las mismas funciones que hay en \texttt{Prelude})
que tienen orden lineal. Esto resulta en costo lineal para trabajo y profundidad:

\begin{equation*}
    W \left( showtS \; s \right) \in
    O \left( \vert s \vert \right)
\end{equation*}

\begin{equation*}
    S \left( showtS \; s \right) \in
    O \left( \vert s \vert \right)
\end{equation*}


\section*{\texttt{reduceS}}

Para la implementación de \texttt{reduceS} con listas se usa la función \texttt{contract}
que toma una operación binaria $\oplus$ y una secuencia $s$ y la contrae aplicando
la operación binaria a cada par de elementos contiguos. Para esto se calcula la
operación entre dichos elementos en paralelo al cálculo del paso recursivo de
\texttt{contract}, resultando en la suma de los trabajos de $\oplus$ para el trabajo
y la suma de las profundidades de $\oplus$ para la profundidad:

\begin{equation*}
    W \left( contract \oplus s \right) \in
    O \left( \sum_{i=0}^{\frac{\vert s \vert}{2} + 1} W \left( s_{2i} \oplus s_{2i+1} \right) \right)
\end{equation*}

\begin{equation*}
    S \left( contract \oplus s \right) \in
    O \left( \sum_{i=0}^{\frac{\vert s \vert}{2} + 1} S \left( s_{2i} \oplus s_{2i+1} \right) \right)
\end{equation*}

Luego, \texttt{reduceS} aplicado a una operación binaria $\oplus$, un elemento $b$
y una secuencia $s$ se calcula aplicando recursivamente \texttt{reduceS} a la
misma operación $\oplus$, el mismo elemento $b$ y la secuencia obtenida de aplicar
\texttt{contract} a $s$, generando el orden de reducción buscado. En el caso del
trabajo, resulta en el tamaño de la secuencia sumado a los trabajos de todas las
aplicaciones de $\oplus$ en el árbol de reducción, mientras que en el caso de la profundidad
resulta en el tamaño de la secuencia sumado a las profundidades de todas las
aplicaciones de $\oplus$ en el árbol de reducción.


\begin{equation*}
    W \left( reduceS \oplus \; b \; s \right) \in
    O \left( \vert s \vert + \sum_{(x \oplus y) \in \mathcal{O}_r(\oplus,b,s)} W \left( x \oplus y \right) \right)
\end{equation*}

\begin{equation*}
    S \left( reduceS \oplus \; b \; s \right) \in
    O \left( \vert s \vert + \sum_{(x \oplus y) \in \mathcal{O}_r(\oplus,b,s)} S \left( x \oplus y \right) \right)
\end{equation*}

\section*{\texttt{scanS}}

\texttt{combine}

\begin{equation*}
    W \left( combine \oplus s \; s' \right) \in
    O \left( \vert s \vert + \sum_{i=1}^{\frac{\vert s \vert}{2}} W \left( s'_{i} \oplus s_{2i - 1} \right) \right)
\end{equation*}

\begin{equation*}
    S \left( combine \oplus s \; s' \right) \in
    O \left( \vert s \vert + \sum_{i=1}^{\frac{\vert s \vert}{2}} S \left( s'_{i} \oplus s_{2i - 1} \right) \right)
\end{equation*}

\begin{equation*}
    W \left( scanS \; s \right) \in
    O \left( algo \right)
\end{equation*}

\begin{equation*}
    S \left( scanS \; s \right) \in O \left( algo \right)
\end{equation*}

\newpage{}

%\setcounter{section}{0}
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%

\part*{Implementación con arreglos persistentes}

\section*{\texttt{filterS}}

Para la implementación con arreglos persistentes de \texttt{filterS} se aplica
la función \texttt{flatten} a una secuencia de tamaño $\vert s \vert$ donde cada
elemento de la misma es o un singleton o una secuencia vacía, de modo que el
trabajo de flatten resulta lineal y la profundidad logarítmica. Esta secuencia,
a su vez, se obtiene aplicando \texttt{tabulate} con una función (que tiene
trabajo y profundidad iguales a los del predicado f) y un tamaño $\vert s \vert$,
resultando entonces en los siguientes costos para \texttt{filterS}:

\begin{equation*}
    W \left( filterS \; f \; s \right) \in
    O \left( \sum_{i=0}^{\vert s \vert -1} W(f \; s_i) \right)
\end{equation*}

\begin{equation*}
    S \left( filterS \; f \; s \right) \in
    O \left( \text{lg} \; \vert s \vert + \max_{i=0}^{\vert s \vert -1} S(f \; s_i) \right)
\end{equation*}


\section*{\texttt{showtS}}

La implementación de \texttt{showtS} con arreglos persistentes usa las funciones
\texttt{takeS} y \texttt{dropS} (ambas con trabajo y profundidad O(1), ya que usan
\texttt{subArray}), de modo que resultan con los siguientes costos:

\begin{equation*}
    W \left( showtS \; s \right) \in
    O \left( 1 \right)
\end{equation*}

\begin{equation*}
    S \left( showtS \; s \right) \in
    O \left( 1 \right)
\end{equation*}


\section*{\texttt{reduceS}}

Para la implementación de \texttt{reduceS} con arreglos persistentes definimos
una función \texttt{contract} que contrae la secuencia dada con una operación
binaria utilizando la función \texttt{tabulate} provista, que a su vez utiliza
una función con el mismo costo que la operación binaria, de modo que el costo
de \texttt{contract} queda de la siguiente manera:

\begin{equation*}
    W \left( contract \oplus s \right) \in
    O \left( \sum_{i=0}^{\frac{\vert s \vert}{2} + 1} W \left( s_{2i} \oplus s_{2i+1} \right) \right)
\end{equation*}

\begin{equation*}
    S \left( contract \oplus s \right) \in
    O \left( \max_{i=0}^{\frac{\vert s \vert}{2} + 1} S \left( s_{2i} \oplus s_{2i+1} \right) \right)
\end{equation*}

Luego, \texttt{reduceS} utiliza \texttt{contract} en cada llamado recursivo,
dividiendo la entrada por 2 en cada paso. En el caso del trabajo, esto resulta
en recorrer la secuencia linealmente, además del trabajo de la operación binaria.
En el caso de la profundidad, \texttt{contract} paraleliza la aplicación de la
función binaria en cada nivel del árbol de reducción, luego la profundidad total
resulta en las profundidades más costosas de cada nivel (que es lg $\vert s \vert$).

\begin{equation*}
    W \left( reduceS \oplus b \; s \right) \in
    O \left( \vert s \vert + \sum_{(x \oplus y) \in \mathcal{O}_r(\oplus,b,s)} W \left( x \oplus y \right) \right)
\end{equation*}

\begin{equation*}
    S \left( reduceS \oplus b \; s \right) \in
    O \left( \text{lg} \; \vert s \vert \; \max_{(x \oplus y) \in \mathcal{O}_r(\oplus,b,s)} S \left( x \oplus y \right) \right)
\end{equation*}

\section*{\texttt{scanS}}

La implementación con arreglos persistentes de \texttt{scanS} también utiliza
la función \texttt{contract} definida por nosotros (cuyo costo está especificado
en el análisis de \texttt{reduceS}) y una nueva función \texttt{combine} que lo
que hace es fusionar una secuencia $s$ y otra secuencia $s'$ mediante la operación
binaria provista, sabiendo que $s'$ es el resultado de \texttt{scanS} aplicado a
$contract s$
\texttt{combine} utiliza \texttt{tabulate} con una función que tiene costo $O \left( 1 \right)$
cuando el índice es par y $O \left( s'_{i} \oplus s_{2i-1} \right)$ cuando el índice 
es impar, de manera que el trabajo y profundidad dependen de éste último caso,
quedando:

\begin{equation*}
    W \left( combine \oplus s \; s' \right) \in
    O \left( \sum_{i=1}^{\frac{\vert s \vert}{2}} W \left( s'_{i} \oplus s_{2i-1} \right) \right)
\end{equation*}

\begin{equation*}
    S \left( combine \oplus s \; s' \right) \in
    O \left( \max_{i=1}^{\frac{\vert s \vert}{2}} S \left( s'_{i} \oplus s_{2i-1} \right) \right)
\end{equation*}

\begin{equation*}
    W \left( scanS \oplus b \; s \right) \in
    O \left( \vert s \vert + \sum_{(x \oplus y) \in \mathcal{O}_s(\oplus,b,s)} W \left( x \oplus y \right) \right)
\end{equation*}

\begin{equation*}
    S \left( scanS \oplus b \; s \right) \in
    O \left( \text{lg} \; \vert s \vert \; \max_{(x \oplus y) \in \mathcal{O}_s(\oplus,b,s)} S \left( x \oplus y \right) \right)
\end{equation*}

\end{document}
